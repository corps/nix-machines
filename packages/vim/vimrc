" set background=dark
" set termguicolors
" set Vim-specific sequences for RGB colors
" let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
" let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
colorscheme srcery

syntax on
set nocompatible
filetype plugin on

set vb                          " Visual bell
set t_Co=256                    " 256 Colors
set t_vb=                       " turn off visual bell
set mouse-=a                     " disable mouse
set hidden                      " don't abadon buffers
set diffopt+=iwhite             " ignore whitespace in diff-mode
set autoread                    " update changed files
let mapleader = "\<tab>"

set hlsearch history=10000 

" set incsearch

" haya14busa/incsearch
" map /  <Plug>(incsearch-forward)
" map ?  <Plug>(incsearch-backward)
" map g/ <Plug>(incsearch-stay)

let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)

" map z/ <Plug>(incsearch-fuzzy-/)
" map z? <Plug>(incsearch-fuzzy-?)
" map zg/ <Plug>(incsearch-fuzzy-stay)
map / <Plug>(incsearch-fuzzy-/)
map ? <Plug>(incsearch-fuzzy-?)
map g/ <Plug>(incsearch-fuzzy-stay)

set backspace=indent,eol,start " Make backspace work cool

set expandtab autoindent tabstop=2 shiftwidth=2
" set foldmethod=indent foldlevel=1000
" set updatetime=500

set ignorecase smartcase        " better searching
set undolevels=10000            " many undos
" set noshelltemp
set noerrorbells                " no bells and whistles
set novisualbell                " no bells and whistles
set grepprg=grep\ -nH\ $*
set shortmess=a
" set rtp+=/usr/share/vim/addons
set shell=bash
set gdefault
set colorcolumn=100
set textwidth=100
set showmatch
set matchtime=5
set laststatus=2 linebreak
set wrap
set showbreak=Â«
set scrolloff=5
set sidescrolloff=5
set sidescroll=1


" create Backup/tmp/undo dirs
function! InitBackupDir()
  let l:parent = $HOME . '/.vim/'
  let l:backup = l:parent . 'backup/'
  let l:tmpdir = l:parent . 'tmp/'
  let l:undodi = l:parent . 'undo/'
  if !isdirectory(l:parent)
    call mkdir(l:parent)
  endif
  if !isdirectory(l:backup)
    call mkdir(l:backup)
  endif
  if !isdirectory(l:tmpdir)
    call mkdir(l:tmpdir)
  endif
  if !isdirectory(l:undodi)
    call mkdir(l:undodi)
  endif
endfunction

call InitBackupDir()

" backup & Files
set backup
set backupdir=~/.vim/backup//
set directory=~/.vim/tmp//
set viminfo='20,<1000,s100,h,n~/.vim/tmp/info
set undodir=~/.vim/undo//
set undofile

" grepping
nmap <leader>g <plug>(GrepperOperator)
xmap <leader>g <plug>(GrepperOperator)

" lessspace.vim
" let g:lessspace_blacklist = ['javascript', 'yaml']


" Allow switching windows even if terminal is open.
tnoremap <C-w>w <C-\><C-n><C-w>w
tnoremap <C-w>W <C-\><C-n><C-w>W

let g:deoplete#enable_at_startup = 1

" let g:neomake_elixir_enabled_makers = ['elixir']
" let g:neomake_elixir_elixir_maker = {
      " \ 'exe' : 'mix',
      " \ 'args': ['compile', '--warnings-as-errors'],
      " \ 'cwd': getcwd(),
      " \ 'errorformat':
        " \ '** %s %f:%l: %m,' .
        " \ '%f:%l: warning: %m'
      " \ }

" airline
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#left_sep = ' '
let g:airline#extensions#tabline#left_alt_sep = '|'
" let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1

" Fuzzy matching (used instead of ctrlp)
nnoremap <leader>p :FuzzyOpen<CR>
" nnoremap <C-p> :FuzzyOpen<CR>

" CtrlP
" let g:ctrlp_max_files = 100000
" let g:ctrlp_match_func = {'match': 'cpsm#CtrlPMatch'}
" React
" let g:jsx_ext_required = 0
" NeoFormat

let g:neoformat_only_msg_on_error = 1
let g:neoformat_enabled_typescript = ['prettier']

function! neoformat#formatters#typescript#prettier() abort
    return {
        \ 'exe': 'prettier',
        \ 'args': [ '--stdin', '--no-bracket-spacing', '--trailing-comma', 'es5', '--eslint-ignore', '--jsx-bracket-same-line'],
        \ 'stdin': 1,
        \ }
endfunction

augroup fmt
  autocmd!
  autocmd BufWritePre * Neoformat
augroup END

set number
let g:vimwiki_list = [{'path': '~/Dropbox/wiki', 'path_html': '~/Dropbox/wiki_html'}]
let g:tex_flavor = "latex"

let g:treeExplVertical = 1
let g:treeExplWinSize = 10
let g:treeExplIndent = 2

" gt for buffer
map gb :bnext<CR>
" gT for buffer
map gB :bprevious<CR>
" close current buffer
map gc :bdelete<CR>
" force close current buffer
map gC :bdelete!<CR>

" vnoremap <c-a> :Inc<CR>
" vnoremap # y?\V<C-R>=substitute(escape(@@,"/\\"),"\n","\\\\n","ge")<CR><CR>
" vnoremap * y/\V<C-R>=substitute(escape(@@,"/\\"),"\n","\\\\n","ge")<CR><CR>

" au BufRead,BufNewFile *.rb set tags=~/izip/darcs/opensource/tags,tags
au BufRead,BufNewFile *.rb set tags=tags,~/c/ramaze/tags
au BufNewFile,BufRead *.m{,ar}{,k}d{,own} set ai formatoptions=tcroqn2 comments=n:> syntax=mkd
au BufNewFile,BufRead *.(byss|rake|ru) set filetype=ruby syntax=ruby
au BufNewFile,BufRead (.irbrc|Vagrantfile) setf ruby
au BufNewFile,BufRead *.st    setf st
au BufNewFile,BufRead *.haml  setf haml
au BufNewFile,BufRead *.neko  setf neko
au BufNewFile,BufRead *.ox    setf oxid
au BufNewFile,BufRead *.fdi   setf xml
au BufNewFile,BufRead *.rl    setf ragel
au BufNewFile,BufRead *.sass  setf sass
au BufNewFile,BufRead *.go    setf go
au BufNewFile,BufRead .envrc  setf sh

au FileType slim set textwidth=0
au FileType ruby,eruby,nagaro set omnifunc=rubycomplete#Complete
au FileType ruby,eruby,nagaro let g:rubycomplete_rails = 0
au FileType ruby,eruby,nagaro let g:rubycomplete_buffer_loading = 1
au FileType ruby,eruby,nagaro let g:rubycomplete_classes_in_global = 1
au FileType ruby,eruby,nagaro let g:rubycomplete_include_object = 1
au FileType ruby,eruby,nagaro let g:rubycomplete_include_object_space = 1

" au FileType neko map <F5> :w<CR>:!rake run:%<CR>
" au FileType oxid map <F5> :w<CR>:!oxid %<CR>
" au FileType ruby map <F5> :w<CR>:!ruby %<CR>

au FileType haskell,vhdl,ada            let b:comment_leader = '-- '
au FileType vim                         let b:comment_leader = '" '
au FileType c,cpp,java,go,typescript    let b:comment_leader = '// '
au FileType sh,make,ruby                let b:comment_leader = '# '
au FileType tex                         let b:comment_leader = '% '
noremap <silent> ,c :<C-B>sil <C-E>s/^/<C-R>=escape(b:comment_leader,'\/')<CR>/<CR>:noh<CR>
noremap <silent> ,u :<C-B>sil <C-E>s/^\V<C-R>=escape(b:comment_leader,'\/')<CR>//e<CR>:noh<CR>
" ,c comments out a region
" ,u uncomments a region

autocmd! BufWritePost * Neomake

au BufEnter,BufRead,BufNewFile *.proto setfiletype proto

highlight WhitespaceEOL ctermbg=red guibg=red
match WhitespaceEOL /\s\+$/
set wildmode=longest,list:longest,full
